1. Block，Ruby里的函数式编程.

2. 在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。

3. 对象中有状态，而函数式中状态则被计算所代替。

4. f(x) = y，那么这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。这也是赋值模型与数学模型的不兼容之处。而函数式编程取消了赋值模型，则使数学模型与编程模型完美地达成了统一。

5. 较为高深的算法要用函数式语言的思想学习更好，那么复杂的数据结构用什么来学？

6. 循环有状态，而递归无状态。

7. 尾递归的原理，与树形递归不同，其实尾递归就是不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间。这样的话，占用的栈空间就是常数阶的了。

8. 斐波那契尾递归的写法：
	def Fib(a,b,n): 
	    if n==0: 
		return b 
	    else: 
		return Fib(b,a+b,n-1)

9. 惰性求值：就是延迟求值，在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在該值被取用的时候求值，也就是说，语句如x:=expression;(把一个表达式的结果赋值给一个变量)明显的调用这个表达式被计算并把结果放置到
x 中，但是先不管实际在 x 中的是什么，直到通过后面的表达式中到 x 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。  
所以惰性求值可以表达“无限”的函数，而等到实际需要计算时，用有限去限定无限：take 10 (repeat Fib(a, b, infinite))

10. 最简单的惰性求值和并行。
	def getResult(): 
	    a = getA()   //Take a long time 
	    b = getB()   //Take a long time 
	    c = a + b
这段代码本身很简单，在命令式程序设计中，编译器（或解释器）会做的就是逐一解释代码，按顺序求出a和b的值，然后再求出c。  
可是我们从并行的角度考虑，求a的值是不是可以和求b的值并行呢？也就是说，直到执行到a+b的时候我们编译器才意识到a和b直到现在才需要，那么我们双核处理器就自然去发挥去最大的功效去计算了呢！  
